<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Django_내장 클래스 기반 제네릭 뷰 - 세진이의 개발노트</title><!-- Links--><link rel="canonical" href="https://jin9173.github.io/2020/01/29/documentation/django/2020-01-29_django_builtin_generic_views"><!-- preload--><!-- Icons--><!-- open graph--><meta name="description" content="출처: django-built-in class-based generic views    내장 클래스 기반 제네릭 뷰 특정 패턴은 반복되기 때문에 웹 애플리케이션 코드는 단조로울 수 있다. 장고는 모델과 템플릿 층에서 그 단조로움을 없애려고 하지만 웹 개발자들은 뷰 레벨에서 지루함을 경험한다.  장고의 제너릭뷰는 개발자들의 고통을 덜기 위해 개발되었다. 제네">
<meta property="og:type" content="article">
<meta property="og:title" content="Django_내장 클래스 기반 제네릭 뷰">
<meta property="og:url" content="https://jin9173.github.io/2020/01/29/documentation/django/2020-01-29_django_builtin_generic_views/">
<meta property="og:site_name" content="세진이의 개발노트">
<meta property="og:description" content="출처: django-built-in class-based generic views    내장 클래스 기반 제네릭 뷰 특정 패턴은 반복되기 때문에 웹 애플리케이션 코드는 단조로울 수 있다. 장고는 모델과 템플릿 층에서 그 단조로움을 없애려고 하지만 웹 개발자들은 뷰 레벨에서 지루함을 경험한다.  장고의 제너릭뷰는 개발자들의 고통을 덜기 위해 개발되었다. 제네">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-29T06:22:50.000Z">
<meta property="article:modified_time" content="2020-01-29T10:51:41.308Z">
<meta property="article:author" content="Sejin Kim">
<meta property="article:tag" content="Bulit in">
<meta property="article:tag" content="Generic View">
<meta name="twitter:card" content="summary"><!-- verify website ownership--><!-- styles--><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/dracula.css"><!-- JSON LD for SEO--><script type="application/ld+json">{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Django_내장 클래스 기반 제네릭 뷰",
  "alternativeHeadline": null,
  "image": {
    "@type": "imageObject",
    "url": null,
    "width": null,
    "height": null
  },
  "genre": null,
  "keywords": "Bulit in,Generic View",
  "editor": {
    "@type": "Person",
    "name": "Sejin Kim"
  },
  "publisher": {
    "@type": "Person",
    "name": "Sejin Kim"
  },
  "author": {
    "@type": "Person",
    "name": "Sejin Kim"
  },
  "url": "https://jin9173.github.io/2020/01/29/documentation/django/2020-01-29_django_builtin_generic_views/",
  "dateCreated": "2020-01-29",
  "datePublished": "2020-01-29",
  "articleBody": "출처: django-built-in class-based generic views    내장 클래스 기반 제네릭 뷰 특정 패턴은 반복되기 때문에 웹 애플리케이션 코드는 단조로울 수 있다. 장고는 모델과 템플릿 층에서 그 단조로움을 없애려고 하지만 웹 개발자들은 뷰 레벨에서 지루함을 경험한다.  장고의 제너릭뷰는 개발자들의 고통을 덜기 위해 개발되었다. 제네릭뷰는 뷰 개발에서 특정한 어법과 패턴을 취하고 추상화하여 너무 많은 코드를 작성하지 않고도 데이터의 일"
}</script><!--scripts--><meta name="generator" content="Hexo 4.2.0"></head><body class="post"><header class="header hero"><div class="hero-wrapper"><div class="gnb"><a href="/">세진이의 개발노트</a><button class="nav-toggle" type="button" aria-haspopup="true" aria-controls="navigation"><span></span><span></span><span></span>menu</button></div><h1 class="header__title">Django_내장 클래스 기반 제네릭 뷰</h1></div></header><div class="contents--container" role="main"><article class="article"><div class="article__meta"><time class="article__meta__time" datetime="2020-01-29T06:22:50.000Z"><span aria-label="posted"><span class="fas fa-calendar-day" aria-hidden="true"></span></span>2020-01-29 15:22:50</time><div class="article__meta__category"><span aria-label="category"><span class="fas fa-archive" aria-hidden="true"></span></span><a class="article__meta__category__item" href="/categories/%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8-%EB%B2%88%EC%97%AD/">도큐먼트 번역</a><a class="article__meta__category__item" href="/categories/%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8-%EB%B2%88%EC%97%AD/django-Framework/">django Framework</a></div></div><div class="article__content"><p>출처: <a href="https://docs.djangoproject.com/en/3.0/topics/class-based-views/generic-display/" target="_blank" rel="noopener">django-built-in class-based generic views</a></p>
<h2 id="내장-클래스-기반-제네릭-뷰"><a href="#내장-클래스-기반-제네릭-뷰" class="headerlink" title="내장 클래스 기반 제네릭 뷰"></a>내장 클래스 기반 제네릭 뷰</h2><p>특정 패턴은 반복되기 때문에 웹 애플리케이션 코드는 단조로울 수 있다. 장고는 모델과 템플릿 층에서 그 단조로움을 없애려고 하지만 웹 개발자들은 뷰 레벨에서 지루함을 경험한다. </p>
<p>장고의 제너릭뷰는 개발자들의 고통을 덜기 위해 개발되었다. 제네릭뷰는 뷰 개발에서 특정한 어법과 패턴을 취하고 추상화하여 너무 많은 코드를 작성하지 않고도 데이터의 일반적인 뷰를 빠르게 작성하게 도와준다. </p>
<p>객체 목록 표시와 같은 일반적인 작업을 인식하고 객체 목록을 표시하는 코드를 작성할 수 있다. 그리고나서 해당 모델을 URLconf에 추가 인수로 전달할 수 있다. </p>
<p>장고는 다음과 같은 제너릭 뷰를 제공:</p>
<ul>
<li>단일 객체의 목록과 세부사항 페이지를 표시. 만약 회의를 관리하는 애플리케이션을 작성한다면 <code>TalkListView</code>와 <code>RegisteredUserListView</code>가 목록 뷰의 예이다. 단일 Talk 페이지는 “Detail” 뷰의 예이다. </li>
<li>년/월/일 아카이브 페이지, 관련 세부사항과 “최신” 페이지에 날짜 기반 객체를 제공</li>
<li>권한이 있거나 없는 사용자가 객체를 생성, 업데이트 및 삭제</li>
</ul>
<p>즉, 이 뷰는 개발자가 겪는 가장 일반적인 작업을 수행하기 위한 인터페이스를 제공한다.</p>
<h3 id="제네릭-뷰-확장"><a href="#제네릭-뷰-확장" class="headerlink" title="제네릭 뷰 확장"></a>제네릭 뷰 확장</h3><p>제네릭 뷰를 사용하면 개발 속도를 크게 높일 수 있다. 그러나 대부분의 프로젝트에서 제네릭 뷰가 충분하지 않은 순간이 있다. 실제로, 장고 개발자가 가장 많이 묻는 질문은 제네릭뷰를 다양한 상황에서 처리하는 방법이다. </p>
<p>이 것이 장고의 1.3 버전에서 제네릭 뷰가 설계된 이유 중 하나이다. 이전의 제네릭 뷰는 애매한 옵션 배열을 가진 뷰 함수였다. 이제는 URLconf에서 많은 양의 설정을 전달하는 대신, 제네릭 뷰를 확장하는데 권장되는 방법은 뷰를 서브클래스화하고 해당 속성 또는 메서드를 재정의하는 것이다. </p>
<p>즉, 제네릭뷰에는 한계가 있다. 뷰를 제네릭 뷰의 서브 클래스로 구현하려고 고군분투하고 있다면 자신만의 클래스 기반 또는 함수형 뷰를 사용하여 필요한 코드만을 작성하는 것이 더 효과적일 수 있다. </p>
<p>일부 타사 응용 프로그램에서 제네릭뷰에 대한 추가 예를 사용하거나 필요에 따라 직접 작성할 수 있다. </p>
<h3 id="객체의-제네릭-뷰"><a href="#객체의-제네릭-뷰" class="headerlink" title="객체의 제네릭 뷰"></a>객체의 제네릭 뷰</h3><p><code>TemplateView</code>는 확실히 유용하지만, 장고의 제네릭 뷰는 데이터베이스 콘텐츠의 뷰를 만들 때 빛이 난다. 장고는 일반적인 작업이므로 객체의 목록 및 상세 뷰를 생성하는데 도움이되는 몇 가지 내장 제네릭 뷰가 있다. </p>
<p>객체 목록 또는 개별 객체를 보여주는 몇 가지 예를 살펴보자.</p>
<p>이 모델들을 사용할 것이다:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    address = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">60</span>)</span><br><span class="line">    state_province = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    country = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    website = models.URLField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">"-name"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    salutation = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    email = models.EmailField()</span><br><span class="line">    headshot = models.ImageField(upload_to=<span class="string">'author_headshots'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    authors = models.ManyToManyField(<span class="string">'Author'</span>)</span><br><span class="line">    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)</span><br><span class="line">    publication_date = models.DateField()</span><br></pre></td></tr></table></figure>

<p>이제 뷰를 정의해야 한다:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Publisher</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherList</span><span class="params">(ListView)</span>:</span></span><br><span class="line">    model = Publisher</span><br></pre></td></tr></table></figure>

<p>마지막으로 해당 뷰를 URL에 연결:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> books.views <span class="keyword">import</span> PublisherList</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'publishers/'</span>, PublisherList.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>이 것이 우리가 작성해야하는 모든 파이썬 코드이다. 그러나 여전히 템플릿을 작성해야 한다. 뷰에 <code>template_name</code> 속성을 추가하여 사용할 템플릿을 명시적으로 알 수 있지만 명시적인 템플릿이 없으면 장고는 객체 이름에서 템플릿을 유추한다. 이 경우 유추된 템플릿은 <code>books/publisher_list.html</code>이다. <code>book</code>은 모델을 정의하는 앱 이름이지만 <code>publisher</code>는 모델 이름의 소문자 버전이다. </p>
<blockquote>
<h5 id="메모"><a href="#메모" class="headerlink" title="메모"></a>메모</h5><p>따라서, (예를 들어) 장고 템플릿 백엔드의 <code>APP_DIRS</code> 옵션이 <code>TEMPLATES</code>에서 <code>TRUE</code>로 설정되면 템플릿의 위치는:</p>
<p><code>/path/to/project/books/templates/books/publisher_list.html</code></p>
</blockquote>
<p>이 템플릿은 <code>publisher</code> 객체를 포함하는 <code>object_list</code>라는 변수가 포함된 컨텍스트에 렌더링된다. 템플릿은 다음과 같다:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends <span class="string">"base.html"</span> %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;h2&gt;Publishers&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;% <span class="keyword">for</span> publisher <span class="keyword">in</span> object_list %&#125;</span><br><span class="line">            &lt;li&gt;&#123;&#123; publisher.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>이게 전부이다. 제네 뷰의 멋진 기능들을 사용하려면 제네릭 뷰에서 설정한 속성을 변경하면 된다. 제네릭뷰의 문서는 모든 제네릭 뷰와 그 옵션에 대해 자세히 설명한다. 이 문서의 나머지 부분에서는 제네릭 뷰를 커스터마이징하고 확장하는 일반적인 방법을 설명한다. </p>
<h3 id="“친숙한”-템플릿-컨텍스트-만들기"><a href="#“친숙한”-템플릿-컨텍스트-만들기" class="headerlink" title="“친숙한” 템플릿 컨텍스트 만들기"></a>“친숙한” 템플릿 컨텍스트 만들기</h3><p>눈치 챘을지 모르겠지만 샘플 <code>publisher</code>리스트 템플릿은 모든 <code>publisher</code>를 <code>object_list</code>라는 변수에 저장한다. 이 방법은 잘 작동하지만, 템플릿 제작자에게는 친숙하지 않다. 여기서 <code>publisher</code>와 작업하고 있다는 것을 알아야 한다. </p>
<p>당신이 모델 객체를 다루고 있다면, 이미 모든 것이 작성되어져 있다. 장고는 객체 또는 쿼리셋을 처리할 때 소문자 버전의 모델 클래스 이름을 사용하여 컨텍스트를 채울 수 있다. 이는 디폴트인 <code>object_list</code> 항목도 제공하지만 정확히 동일한 데이터도 제공한다(i.e. <code>publisher_list</code>). </p>
<p>그래도 일치하지 않으면 컨텍스트 변수의 이름을 수동으로 설정할 수 있다. 제네릭 뷰의 <code>context_object_name</code> 속성은 사용할 컨텍스트 변수를 구체적으로 명시한다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Publisher</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherList</span><span class="params">(ListView)</span>:</span></span><br><span class="line">    model = Publisher</span><br><span class="line">    context_object_name = <span class="string">'my_favorite_publishers'</span></span><br></pre></td></tr></table></figure>

<p>유용한 <code>context_object_name</code>을 제공하는 것은 항상 옳다. 템플릿을 디자인하는 당신의 동료가 고마워할 것이다. </p>
<h3 id="추가-컨텍스트"><a href="#추가-컨텍스트" class="headerlink" title="추가 컨텍스트"></a>추가 컨텍스트</h3><p>종종 제네릭 뷰가 제공하는 것 이외의 추가 정보를 명시해야 한다. 예를 들어, 각 <code>publisher</code>의 세부사항 페이지에 모든 책들의 목록을 표시한다고 가정하자. <code>DetailView</code> 제네릭 뷰는 <code>publisher</code>에게 컨텍스트를 제공하지만 해당 템플릿에서 추가 정보를 어떻게 얻을까?</p>
<p>정답은 <code>DetailView</code>를 서브클래스화하고 <code>get_context_data</code> 메소드의 직접 구현하는 것이다. default는 객체를 템플릿에 추가하지만 더 많이 보내도록 재정의할 수 있다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> DetailView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Book, Publisher</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherDetail</span><span class="params">(DetailView)</span>:</span></span><br><span class="line"></span><br><span class="line">    model = Publisher</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Call the base implementation first to get a context</span></span><br><span class="line">        context = super().get_context_data(**kwargs)</span><br><span class="line">        <span class="comment"># Add in a QuerySet of all the books</span></span><br><span class="line">        context[<span class="string">'book_list'</span>] = Book.objects.all()</span><br><span class="line">        <span class="keyword">return</span> context</span><br></pre></td></tr></table></figure>

<blockquote>
<h5 id="메모-1"><a href="#메모-1" class="headerlink" title="메모"></a>메모</h5><p>일반적으로 <code>get_context_data</code>는 모든 부모 클래스의 컨텍스트 데이터를 현재 클래스의 컨텍스트 데이터와 병합한다. 변경하려는 컨텍스트의 클래스에서 이 동작을 유지하려면 수퍼클래스에서 <code>get_context_data</code>를 호출해야한다. 두 클래스가 동일한 키를 정의하지 않으면, 예상된 결과가 나타난다. 그러나 부모 클래스가 (super 호출 후) 키를 설정한 후 다른 클래스가 이 키를 대체하려고 시도하면 super 호출 후 해당 자식 클래스도 이 키를 명시해주어야 모든 부모 클래스를 재정의할 수 있다. 문제가 발생한다면 뷰의 resolution 메소드를 검토한다.</p>
<p>또 다른 고려사항은 클래스 기반 제네릭 뷰의 컨텍스트 데이터가 컨텍스트 프로세서에서 제공한 데이터를 재정의한다는 것이다. 예제는 <code>get_context_data()</code>를 참조한다.</p>
</blockquote>
<h3 id="객체의-서프셋-보기"><a href="#객체의-서프셋-보기" class="headerlink" title="객체의 서프셋 보기"></a>객체의 서프셋 보기</h3><p>이제 우리가 지금껏 사용한 모델 인수에 대해 살펴보자. 뷰가 작동할 데이터베이스 모델을 구체적으로 명시하는 모델 인수는 단일 객체나 객체 컬렉션에서 작동하는 모든 제네릭 뷰에서 사용 가능하다. 그러나 모델 인수는 뷰가 작동할 객체를 지정하는 유일한 방법일 뿐만 아니라 쿼리셋 인수를 사용하여 객체 목록을 지정할 수도 있다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> DetailView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Publisher</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherDetail</span><span class="params">(DetailView)</span>:</span></span><br><span class="line"></span><br><span class="line">    context_object_name = <span class="string">'publisher'</span></span><br><span class="line">    queryset = Publisher.objects.all()</span><br></pre></td></tr></table></figure>

<p><code>model</code> 지정 = <code>Publisher</code>는 쿼리셋을 의미 = <code>Publisher.objects.all()</code>. 그러나 쿼리셋을 사용하여 필터링 된 객체 목록을 정의하면 뷰에 표시될 객체를 보다 구체적으로 지정할 수 있다. (쿼리셋 객체에 대한 자세한 정보는 조회 작성과 전체 세부 사항은 클래스 기반 뷰를 참조하시오.) </p>
<p>예를 들어, 가장 최근의 출판 날짜별로 책 목록을 나열할 수 있다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Book</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookList</span><span class="params">(ListView)</span>:</span></span><br><span class="line">    queryset = Book.objects.order_by(<span class="string">'-publication_date'</span>)</span><br><span class="line">    context_object_name = <span class="string">'book_list'</span></span><br></pre></td></tr></table></figure>

<p>그 것은 작은 예이지만 설명하고자 하는 것을 훌륭하게 보여준다. 물론 일반적으로 객체를 재정렬하는 것 이상의 작업을 원할 것이다. 특정 <code>publisher</code>에서 책 목록을 보여줄 경우 동일하게 구현 가능하다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Book</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcmeBookList</span><span class="params">(ListView)</span>:</span></span><br><span class="line"></span><br><span class="line">    context_object_name = <span class="string">'book_list'</span></span><br><span class="line">    queryset = Book.objects.filter(publisher__name=<span class="string">'ACME Publishing'</span>)</span><br><span class="line">    template_name = <span class="string">'books/acme_list.html'</span></span><br></pre></td></tr></table></figure>

<p>필터링 된 쿼리셋과 함께 커스텀 템플릿 이름도 사용하고 있다. 그렇지 않은 경우, 제네릭 뷰는 “vanilla” 객체 목록과 동일한 템플릿을 사용하므로 원하는 형식이 아닐 수 있다. </p>
<p>또한 이는 출판사 별 도서를 만드는 좋은 방법이 아니다. 다른 게시자 페이지를 추가하려면 URLconf에 몇줄의 코드를 추가해야하며 몇몇 <code>publisher</code>는 바람직하지 않을 수도 있다. 다음 섹션에서 이 문제를 다룰 것이다. </p>
<blockquote>
<h5 id="메모-2"><a href="#메모-2" class="headerlink" title="메모"></a>메모</h5><p><code>/books/acme/</code>를 요청할 때 404가 뜨면, <code>ACME Publishing</code>인 게시자가 실제로 있는지 확인하라. 이 경우 제네릭 뷰에는 <code>allow_empty</code> 매개 변수가 있다. 자세한 내용은 클래스 기반 뷰를 참조하라.</p>
</blockquote>
<h3 id="동적-필터링"><a href="#동적-필터링" class="headerlink" title="동적 필터링"></a>동적 필터링</h3><p>또 다른 일반적인 필요는 URL의 일부 키로 목록 페이지에 제공된 객체를 필터링하는 것이다. 이전에 URLconf에 게시자 이름을 변경할 수 없게 기록(hard-coding)했지만 임의의 게시자가 모든 책을 표시하는 뷰를 작성하려면 어떻게해야 할까?</p>
<p>간단히 말하자면, <code>ListView</code>에는 재정의할 수 있는 <code>get_queryset()</code> 메소드가 있다. 기본적으로 쿼리셋 속성값을 반환하지만 더 많은 로직을 추가하는데 사용할 수 있다. </p>
<p>이 작업의 핵심은 클래스 기반 뷰가 호출될 때, 다양하고 유용한 것들이 자동으로 저장된다는 것이다. 마찬가지로 요청(<code>self.request</code>)뿐만 아니라 URLconf에 따라 캡처된 위치(<code>self.args</code>) 및 이름 기반(<code>self.kwargs</code>)인수가 포함된다. </p>
<p>여기에 하나의 캡처 그룹이 있는 URLconf가 있다:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> books.views <span class="keyword">import</span> PublisherBookList</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'books/&lt;publisher&gt;/'</span>, PublisherBookList.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>다음으로 <code>PublisherBookList</code> 뷰를 작성한다:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Book, Publisher</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherBookList</span><span class="params">(ListView)</span>:</span></span><br><span class="line"></span><br><span class="line">    template_name = <span class="string">'books/books_by_publisher.html'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.publisher = get_object_or_404(Publisher, name=self.kwargs[<span class="string">'publisher'</span>])</span><br><span class="line">        <span class="keyword">return</span> Book.objects.filter(publisher=self.publisher)</span><br></pre></td></tr></table></figure>

<p><code>get_queryset</code>을 사용하여 쿼리셋 셀렉션에 로직을 추가하는 것은 편리하다. 예를 들어, 원한다면 <code>self.request.user</code>를 사용하여 현재 사용자 또는 다른 복잡한 로직을 사용하여 필터링할 수 있다. </p>
<p>또한 게시자를 컨텍스트에 동시에 추가하여 템플릿을 사용할 수 있다:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># Call the base implementation first to get a context</span></span><br><span class="line">    context = super().get_context_data(**kwargs)</span><br><span class="line">    <span class="comment"># Add in the publisher</span></span><br><span class="line">    context[<span class="string">'publisher'</span>] = self.publisher</span><br><span class="line">    <span class="keyword">return</span> context</span><br></pre></td></tr></table></figure>

<h3 id="추가-작업-수행"><a href="#추가-작업-수행" class="headerlink" title="추가 작업 수행"></a>추가 작업 수행</h3><p>마지막으로 볼 수 있는 일반적인 패턴은 제네릭 뷰를 호출하기 전이나 후에 추가 작업을 수행하는 것이다. </p>
<p>그 저자를 마지막으로 본 사람을 추적하기 위해 사용했던 <code>Author model</code>에서 <code>last_accessed</code> 필드를 가지고 있다고 가정해보자. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    salutation = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    email = models.EmailField()</span><br><span class="line">    headshot = models.ImageField(upload_to=<span class="string">'author_headshots'</span>)</span><br><span class="line">    last_accessed = models.DateTimeField()</span><br></pre></td></tr></table></figure>

<p>물론 <code>DetailView</code> 제네릭 클래스는 이 필드에 대해 아무것도 알지 못하지만 다시 한번 해당 필드를 업데이트하기 위해 커스텀 뷰를 쉽게 작성할 수 있다. </p>
<p>먼저 커스텀뷰를 가리키려면 URLconf에 작성자 세부사항을 추가해야 한다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> books.views <span class="keyword">import</span> AuthorDetailView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    path(<span class="string">'authors/&lt;int:pk&gt;/'</span>, AuthorDetailView.as_view(), name=<span class="string">'author-detail'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>그런 다음 새로운 뷰를 작성한다. <code>get_object</code>는 객체를 검색하는 메소드이다. 따라서 이를 재정의하고 호출을 래핑한다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> DetailView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Author</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetailView</span><span class="params">(DetailView)</span>:</span></span><br><span class="line"></span><br><span class="line">    queryset = Author.objects.all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self)</span>:</span></span><br><span class="line">        obj = super().get_object()</span><br><span class="line">        <span class="comment"># Record the last accessed date</span></span><br><span class="line">        obj.last_accessed = timezone.now()</span><br><span class="line">        obj.save()</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>

</div><div class="article__tags"><div class="article__tags__title">tags:</div><a class="article__tag__item" href="/tags/Bulit-in/"><span class="fas fa-tag" aria-hidden="true"></span>Bulit in</a><a class="article__tag__item" href="/tags/Generic-View/"><span class="fas fa-tag" aria-hidden="true"></span>Generic View</a></div></article><div class="comment__container" role="region" aria-label="comments"></div></div><footer class="footer"><p class="credit">Powered by  <a href="https://hexo.io/" rel="external noreferrer" target="_blank">Hexo</a>. Theme by  <a href="https://github.com/mulder21c" rel="external noreferrer" target="_blank">Sejin Kim</a></p></footer><div class="nav" aria-hidden="true"><nav class="nav--container" id="navigation" aria-labelledby="nav__heading"><h2 class="nav__heading" id="nav__heading">Navigation</h2><hr class="nav__seperator"><ul class="menu-list">
    <li class="menu-item" >
      <a href="/" >
        home
      </a>
    </li>
    <li class="menu-item" >
      <a href="/archives" >
        archives
      </a>
    </li></ul><hr class="nav__seperator"><h3 class="nav__heading--sub">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Setting/">Setting</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%EA%B3%B5%EB%B6%80/">공부</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%EA%B3%B5%EB%B6%80/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%EA%B3%B5%EB%B6%80/Server/">Server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%EA%B3%B5%EB%B6%80/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">디자인 패턴</a></li></ul></li><li class="category-list-item"><a class="category-list-link current" href="/categories/%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8-%EB%B2%88%EC%97%AD/">도큐먼트 번역</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link current" href="/categories/%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8-%EB%B2%88%EC%97%AD/django-Framework/">django Framework</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/Python/">Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/%EC%9E%A5%EA%B3%A0-%EB%B8%94%EB%A1%9C%EA%B7%B8/">장고 블로그</a></li></ul></li></ul></nav></div><script src="/js/webfontloader.js"></script><script>WebFont.load({
  custom: {
    families: ["Noto Sans KR", "Font Awesome"],
    urls: ["/fonts/notosanskr/NotoSansKR.css", "/fonts/fontawesome/fontawesome.css"]
  }
});</script><script src="/js/script.js"></script></body></html>